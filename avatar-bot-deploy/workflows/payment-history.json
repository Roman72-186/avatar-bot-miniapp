{
  "name": "[MINIAPP] payment-history",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "ph-webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        300
      ],
      "parameters": {
        "path": "payment-history",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "ph-validate",
      "name": "Validate initData",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        450,
        300
      ],
      "parameters": {
        "jsCode": "// Telegram initData HMAC-SHA256 validation — pure JS (no crypto module needed)\nconst BOT_TOKEN = '{{BOT_TOKEN}}';\nconst MAX_AGE = 86400;\nfunction _sha256(data){const K=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];let h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a,h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19;const m=Array.from(data),l=m.length*8;m.push(0x80);while(m.length%64!==56)m.push(0);m.push(0,0,0,0,(l>>>24)&0xff,(l>>>16)&0xff,(l>>>8)&0xff,l&0xff);for(let o=0;o<m.length;o+=64){const W=[];for(let i=0;i<16;i++)W[i]=(m[o+i*4]<<24)|(m[o+i*4+1]<<16)|(m[o+i*4+2]<<8)|m[o+i*4+3];for(let i=16;i<64;i++){const s0=((W[i-15]>>>7)|(W[i-15]<<25))^((W[i-15]>>>18)|(W[i-15]<<14))^(W[i-15]>>>3);const s1=((W[i-2]>>>17)|(W[i-2]<<15))^((W[i-2]>>>19)|(W[i-2]<<13))^(W[i-2]>>>10);W[i]=(W[i-16]+s0+W[i-7]+s1)|0;}let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7;for(let i=0;i<64;i++){const S1=((e>>>6)|(e<<26))^((e>>>11)|(e<<21))^((e>>>25)|(e<<7));const ch=(e&f)^(~e&g);const t1=(h+S1+ch+K[i]+W[i])|0;const S0=((a>>>2)|(a<<30))^((a>>>13)|(a<<19))^((a>>>22)|(a<<10));const maj=(a&b)^(a&c)^(b&c);const t2=(S0+maj)|0;h=g;g=f;f=e;e=(d+t1)|0;d=c;c=b;b=a;a=(t1+t2)|0;}h0=(h0+a)|0;h1=(h1+b)|0;h2=(h2+c)|0;h3=(h3+d)|0;h4=(h4+e)|0;h5=(h5+f)|0;h6=(h6+g)|0;h7=(h7+h)|0;}const r=[];for(const v of[h0,h1,h2,h3,h4,h5,h6,h7])r.push((v>>>24)&0xff,(v>>>16)&0xff,(v>>>8)&0xff,v&0xff);return r;}\nfunction _hmac(keyB,msgB){let k=Array.from(keyB);if(k.length>64)k=_sha256(k);while(k.length<64)k.push(0);const ip=k.map(b=>b^0x36),op=k.map(b=>b^0x5c);return _sha256(op.concat(_sha256(ip.concat(Array.from(msgB)))));}\nfunction _s2b(s){const b=[];for(let i=0;i<s.length;i++){let c=s.charCodeAt(i);if(c<0x80){b.push(c);}else if(c<0x800){b.push(0xC0|(c>>6),0x80|(c&0x3F));}else if(c>=0xD800&&c<=0xDBFF){const h=c,l=s.charCodeAt(++i),p=((h-0xD800)<<10)+(l-0xDC00)+0x10000;b.push(0xF0|(p>>18),0x80|((p>>12)&0x3F),0x80|((p>>6)&0x3F),0x80|(p&0x3F));}else{b.push(0xE0|(c>>12),0x80|((c>>6)&0x3F),0x80|(c&0x3F));}}return b;}\nfunction _hex(bytes){return bytes.map(b=>b.toString(16).padStart(2,'0')).join('');}\nconst body=($input.first().json.body)||{};const initData=body.init_data||'';\nif(!initData){return[{json:{...$input.first().json,_auth_valid:false}}];}\ntry{const params={};for(const pair of initData.split('&')){const idx=pair.indexOf('=');if(idx===-1)continue;params[decodeURIComponent(pair.slice(0,idx))]=decodeURIComponent(pair.slice(idx+1));}if(!params.hash)throw new Error('no hash');if(!params.auth_date)throw new Error('no auth_date');if(!params.user)throw new Error('no user');const authDate=Number(params.auth_date);if(!authDate||authDate<1000000000)throw new Error('invalid auth_date');const age=Math.floor(Date.now()/1000)-authDate;if(age>MAX_AGE)throw new Error('expired');if(age<-300)throw new Error('future auth_date');const checkString=Object.keys(params).filter(k=>k!=='hash').sort().map(k=>k+'='+params[k]).join('\\n');const secret=_hmac(_s2b('WebAppData'),_s2b(BOT_TOKEN));const computed=_hex(_hmac(secret,_s2b(checkString)));if(computed!==params.hash)throw new Error('bad hash');let user={};try{user=JSON.parse(params.user);}catch(e){throw new Error('invalid user json');}if(!user.id)throw new Error('no user.id');const reqUserId=String(body.user_id||'');if(reqUserId&&String(user.id)!==reqUserId){throw new Error('user mismatch: '+user.id+' vs '+reqUserId);}return[{json:{...$input.first().json,_auth_valid:true}}];}catch(e){console.error('initData validation failed:',e.message);return[{json:{...$input.first().json,_auth_valid:false,_auth_error:e.message}}];}\n"
      }
    },
    {
      "id": "ph-auth-if",
      "name": "Auth Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        650,
        300
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "auth-check",
              "leftValue": "={{ $json._auth_valid }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "ph-unauth",
      "name": "Respond Unauthorized",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        850,
        500
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\"error\": \"unauthorized\", \"message\": \"Invalid or missing Telegram initData\"}",
        "options": {
          "responseCode": 403
        }
      }
    },
    {
      "id": "ph-sql",
      "name": "Get Payments",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        850,
        300
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "=DO $$ BEGIN\n  ALTER TABLE payments_log ADD COLUMN IF NOT EXISTS bonus INTEGER DEFAULT 0;\n  ALTER TABLE payments_log ADD COLUMN IF NOT EXISTS total_credited INTEGER DEFAULT 0;\nEXCEPTION WHEN OTHERS THEN NULL;\nEND $$;\n\nSELECT id, stars, COALESCE(bonus, 0) as bonus, COALESCE(total_credited, stars) as total_credited, created_at FROM payments_log WHERE user_id = '{{ $json.body.user_id }}' ORDER BY created_at DESC LIMIT 50;",
        "options": {}
      },
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CRED_ID}}",
          "name": "avatar_bot"
        }
      },
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "id": "ph-format",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1050,
        300
      ],
      "parameters": {
        "jsCode": "const items = $input.all().map(i => i.json).filter(i => i.id);\nreturn [{json: {payments: items}}];"
      }
    },
    {
      "id": "ph-respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1250,
        300
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate initData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate initData": {
      "main": [
        [
          {
            "node": "Auth Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auth Valid?": {
      "main": [
        [
          {
            "node": "Get Payments",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Unauthorized",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Payments": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "activeVersionId": "af632715-fcf6-4481-8119-6062f2e4eb11",
  "versionCounter": 9,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-24T14:52:33.127Z",
      "createdAt": "2026-02-24T14:52:33.127Z",
      "role": "workflow:owner",
      "workflowId": "oo87087AVDIY3R3Z",
      "projectId": "UnFAqkOZkFc92cC9",
      "project": {
        "updatedAt": "2026-01-19T08:59:40.920Z",
        "createdAt": "2026-01-19T07:34:37.219Z",
        "id": "UnFAqkOZkFc92cC9",
        "name": "Роман Махметов <2356592g@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "7b9f38f0-0dfe-404a-a677-ba540bbf50c1"
      }
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-25T03:02:18.890Z",
    "createdAt": "2026-02-25T03:02:18.890Z",
    "versionId": "af632715-fcf6-4481-8119-6062f2e4eb11",
    "workflowId": "oo87087AVDIY3R3Z",
    "nodes": [
      {
        "id": "ph-webhook",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          250,
          300
        ],
        "webhookId": "payment-history",
        "parameters": {
          "path": "payment-history",
          "httpMethod": "POST",
          "responseMode": "responseNode",
          "options": {}
        },
        "onError": "continueRegularOutput"
      },
      {
        "id": "ph-validate",
        "name": "Validate initData",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          450,
          300
        ],
        "parameters": {
          "jsCode": "// Telegram initData HMAC-SHA256 validation — pure JS (no crypto module needed)\nconst BOT_TOKEN = '{{BOT_TOKEN}}';\nconst MAX_AGE = 86400;\nfunction _sha256(data){const K=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];let h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a,h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19;const m=Array.from(data),l=m.length*8;m.push(0x80);while(m.length%64!==56)m.push(0);m.push(0,0,0,0,(l>>>24)&0xff,(l>>>16)&0xff,(l>>>8)&0xff,l&0xff);for(let o=0;o<m.length;o+=64){const W=[];for(let i=0;i<16;i++)W[i]=(m[o+i*4]<<24)|(m[o+i*4+1]<<16)|(m[o+i*4+2]<<8)|m[o+i*4+3];for(let i=16;i<64;i++){const s0=((W[i-15]>>>7)|(W[i-15]<<25))^((W[i-15]>>>18)|(W[i-15]<<14))^(W[i-15]>>>3);const s1=((W[i-2]>>>17)|(W[i-2]<<15))^((W[i-2]>>>19)|(W[i-2]<<13))^(W[i-2]>>>10);W[i]=(W[i-16]+s0+W[i-7]+s1)|0;}let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7;for(let i=0;i<64;i++){const S1=((e>>>6)|(e<<26))^((e>>>11)|(e<<21))^((e>>>25)|(e<<7));const ch=(e&f)^(~e&g);const t1=(h+S1+ch+K[i]+W[i])|0;const S0=((a>>>2)|(a<<30))^((a>>>13)|(a<<19))^((a>>>22)|(a<<10));const maj=(a&b)^(a&c)^(b&c);const t2=(S0+maj)|0;h=g;g=f;f=e;e=(d+t1)|0;d=c;c=b;b=a;a=(t1+t2)|0;}h0=(h0+a)|0;h1=(h1+b)|0;h2=(h2+c)|0;h3=(h3+d)|0;h4=(h4+e)|0;h5=(h5+f)|0;h6=(h6+g)|0;h7=(h7+h)|0;}const r=[];for(const v of[h0,h1,h2,h3,h4,h5,h6,h7])r.push((v>>>24)&0xff,(v>>>16)&0xff,(v>>>8)&0xff,v&0xff);return r;}\nfunction _hmac(keyB,msgB){let k=Array.from(keyB);if(k.length>64)k=_sha256(k);while(k.length<64)k.push(0);const ip=k.map(b=>b^0x36),op=k.map(b=>b^0x5c);return _sha256(op.concat(_sha256(ip.concat(Array.from(msgB)))));}\nfunction _s2b(s){const b=[];for(let i=0;i<s.length;i++){let c=s.charCodeAt(i);if(c<0x80){b.push(c);}else if(c<0x800){b.push(0xC0|(c>>6),0x80|(c&0x3F));}else if(c>=0xD800&&c<=0xDBFF){const h=c,l=s.charCodeAt(++i),p=((h-0xD800)<<10)+(l-0xDC00)+0x10000;b.push(0xF0|(p>>18),0x80|((p>>12)&0x3F),0x80|((p>>6)&0x3F),0x80|(p&0x3F));}else{b.push(0xE0|(c>>12),0x80|((c>>6)&0x3F),0x80|(c&0x3F));}}return b;}\nfunction _hex(bytes){return bytes.map(b=>b.toString(16).padStart(2,'0')).join('');}\nconst body=($input.first().json.body)||{};const initData=body.init_data||'';\nif(!initData){return[{json:{...$input.first().json,_auth_valid:false}}];}\ntry{const params={};for(const pair of initData.split('&')){const idx=pair.indexOf('=');if(idx===-1)continue;params[decodeURIComponent(pair.slice(0,idx))]=decodeURIComponent(pair.slice(idx+1));}if(!params.hash)throw new Error('no hash');if(!params.auth_date)throw new Error('no auth_date');if(!params.user)throw new Error('no user');const authDate=Number(params.auth_date);if(!authDate||authDate<1000000000)throw new Error('invalid auth_date');const age=Math.floor(Date.now()/1000)-authDate;if(age>MAX_AGE)throw new Error('expired');if(age<-300)throw new Error('future auth_date');const checkString=Object.keys(params).filter(k=>k!=='hash').sort().map(k=>k+'='+params[k]).join('\\n');const secret=_hmac(_s2b('WebAppData'),_s2b(BOT_TOKEN));const computed=_hex(_hmac(secret,_s2b(checkString)));if(computed!==params.hash)throw new Error('bad hash');let user={};try{user=JSON.parse(params.user);}catch(e){throw new Error('invalid user json');}if(!user.id)throw new Error('no user.id');const reqUserId=String(body.user_id||'');if(reqUserId&&String(user.id)!==reqUserId){throw new Error('user mismatch: '+user.id+' vs '+reqUserId);}return[{json:{...$input.first().json,_auth_valid:true}}];}catch(e){console.error('initData validation failed:',e.message);return[{json:{...$input.first().json,_auth_valid:false,_auth_error:e.message}}];}\n"
        }
      },
      {
        "id": "ph-auth-if",
        "name": "Auth Valid?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          650,
          300
        ],
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 2
            },
            "conditions": [
              {
                "id": "auth-check",
                "leftValue": "={{ $json._auth_valid }}",
                "rightValue": "",
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        }
      },
      {
        "id": "ph-unauth",
        "name": "Respond Unauthorized",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          850,
          500
        ],
        "parameters": {
          "respondWith": "json",
          "responseBody": "{\"error\": \"unauthorized\", \"message\": \"Invalid or missing Telegram initData\"}",
          "options": {
            "responseCode": 403
          }
        }
      },
      {
        "id": "ph-sql",
        "name": "Get Payments",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          850,
          300
        ],
        "parameters": {
          "operation": "executeQuery",
          "query": "=DO $$ BEGIN\n  ALTER TABLE payments_log ADD COLUMN IF NOT EXISTS bonus INTEGER DEFAULT 0;\n  ALTER TABLE payments_log ADD COLUMN IF NOT EXISTS total_credited INTEGER DEFAULT 0;\nEXCEPTION WHEN OTHERS THEN NULL;\nEND $$;\n\nSELECT id, stars, COALESCE(bonus, 0) as bonus, COALESCE(total_credited, stars) as total_credited, created_at FROM payments_log WHERE user_id = '{{ $json.body.user_id }}' ORDER BY created_at DESC LIMIT 50;",
          "options": {}
        },
        "credentials": {
          "postgres": {
            "id": "{{POSTGRES_CRED_ID}}",
            "name": "avatar_bot"
          }
        },
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "id": "ph-format",
        "name": "Format Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1050,
          300
        ],
        "parameters": {
          "jsCode": "const items = $input.all().map(i => i.json).filter(i => i.id);\nreturn [{json: {payments: items}}];"
        }
      },
      {
        "id": "ph-respond",
        "name": "Respond",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          1250,
          300
        ],
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify($json) }}",
          "options": {}
        }
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Validate initData",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate initData": {
        "main": [
          [
            {
              "node": "Auth Valid?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Auth Valid?": {
        "main": [
          [
            {
              "node": "Get Payments",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Respond Unauthorized",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Payments": {
        "main": [
          [
            {
              "node": "Format Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Response": {
        "main": [
          [
            {
              "node": "Respond",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Роман Махметов",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-25T03:02:18.966Z",
        "id": 2281,
        "workflowId": "oo87087AVDIY3R3Z",
        "versionId": "af632715-fcf6-4481-8119-6062f2e4eb11",
        "event": "deactivated",
        "userId": "7b9f38f0-0dfe-404a-a677-ba540bbf50c1"
      },
      {
        "createdAt": "2026-02-25T03:02:19.006Z",
        "id": 2282,
        "workflowId": "oo87087AVDIY3R3Z",
        "versionId": "af632715-fcf6-4481-8119-6062f2e4eb11",
        "event": "activated",
        "userId": "7b9f38f0-0dfe-404a-a677-ba540bbf50c1"
      }
    ]
  }
}